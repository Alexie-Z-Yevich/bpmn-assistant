import xml.etree.ElementTree as ET


class BpmnXmlGenerator:
    """
    Class to generate BPMN XML from the BPMN process data in JSON format.
    """

    def create_bpmn_xml(self, process: list[dict]) -> str:
        """
        Create BPMN XML from the process data.
        Args:
            process: BPMN process structure generated by the LLM.
        Returns:
            The BPMN XML string.
        """

        restructured_process = self._restructure(process)

        # Create the root element (definitions)
        root = ET.Element("definitions")
        root.set("xmlns", "http://www.omg.org/spec/BPMN/20100524/MODEL")
        root.set("xmlns:bpmndi", "http://www.omg.org/spec/BPMN/20100524/DI")
        root.set("xmlns:dc", "http://www.omg.org/spec/DD/20100524/DC")
        root.set("xmlns:di", "http://www.omg.org/spec/DD/20100524/DI")
        root.set("id", "definitions_1")

        # Create the process element
        process = ET.SubElement(root, "process")
        process.set("id", "Process_1")
        process.set("isExecutable", "false")

        # Add elements
        for element in restructured_process["elements"]:
            elem = ET.SubElement(process, element["type"])
            elem.set("id", element["id"])

            # Add label if it exists
            if element["label"]:
                elem.set("name", element["label"])

            # Add incoming and outgoing flows as child elements
            for incoming in element["incoming"]:
                ET.SubElement(elem, "incoming").text = incoming
            for outgoing in element["outgoing"]:
                ET.SubElement(elem, "outgoing").text = outgoing

        # Add flows
        for flow in restructured_process["flows"]:
            seq_flow = ET.SubElement(process, "sequenceFlow")
            seq_flow.set("id", flow["id"])
            seq_flow.set("sourceRef", flow["sourceRef"])
            seq_flow.set("targetRef", flow["targetRef"])

            # Add condition if it exists
            if flow["condition"]:
                seq_flow.set("name", flow["condition"])

        xml_string = ET.tostring(root, encoding="unicode")

        return xml_string

    def _restructure(self, process: list[dict]) -> dict:
        """
        Restructure the original BPMN JSON structure into a new structure more suitable for BPMN XML generation.

        Example output structure::

            {
                "elements": [
                    {
                        "id": "element_id",
                        "type": "element_type",
                        "label": "element_label",
                        "incoming": ["incoming_flow_id"],
                        "outgoing": ["outgoing_flow_id"]
                    }
                ],
                "flows": [
                    {
                        "id": "flow_id",
                        "sourceRef": "source_element_id",
                        "targetRef": "target_element_id",
                        "condition": "flow_condition"
                    }
                ]
            }
        """

        elements = []
        flows = []

        def handle_exclusive_gateway(element: dict):
            for branch in element["branches"]:
                branch_structure = self._restructure(branch["path"])
                elements.extend(branch_structure["elements"])
                flows.extend(branch_structure["flows"])

                # Add the flow from the exclusive gateway to the first element in the branch
                first_element = branch_structure["elements"][0]
                flows.append(
                    {
                        "id": f"{element['id']}-{first_element['id']}",
                        "sourceRef": element["id"],
                        "targetRef": first_element["id"],
                        "condition": branch["condition"],
                    }
                )

        def handle_parallel_gateway(element: dict):
            # Create a 'join' parallel gateway element
            join_gateway_id = f"{element['id']}-join"
            elements.append(
                {
                    "id": join_gateway_id,
                    "type": "parallelGateway",
                    "label": None,
                }
            )

            for branch in element["branches"]:
                branch_structure = self._restructure(branch)
                elements.extend(branch_structure["elements"])
                flows.extend(branch_structure["flows"])

                # Add the flow from the parallel gateway to the first element in the branch
                first_element = branch_structure["elements"][0]
                flows.append(
                    {
                        "id": f"{element['id']}-{first_element['id']}",
                        "sourceRef": element["id"],
                        "targetRef": first_element["id"],
                        "condition": None,
                    }
                )

                # Add the flow from the last element in the branch to the join gateway
                last_element = branch_structure["elements"][-1]
                flows.append(
                    {
                        "id": f"{last_element['id']}-{join_gateway_id}",
                        "sourceRef": last_element["id"],
                        "targetRef": join_gateway_id,
                        "condition": None,
                    }
                )

            return join_gateway_id

        for index, element in enumerate(process):
            # For now we won't bother with the incoming and outgoing flows
            elements.append(
                {
                    "id": element["id"],
                    "type": element["type"],
                    "label": element.get("label", None),
                }
            )

            if element["type"] == "exclusiveGateway":
                handle_exclusive_gateway(element)
            elif element["type"] == "parallelGateway":
                join_gateway_id = handle_parallel_gateway(element)

                # Connect the join gateway to the next element in the process
                if index < len(process) - 1:
                    flows.append(
                        {
                            "id": f"{join_gateway_id}-{process[index + 1]['id']}",
                            "sourceRef": join_gateway_id,
                            "targetRef": process[index + 1]["id"],
                            "condition": None,
                        }
                    )
            else:
                # Add the flow between the current element and the next element in the process
                if index < len(process) - 1:
                    flows.append(
                        {
                            "id": f"{element['id']}-{process[index + 1]['id']}",
                            "sourceRef": element["id"],
                            "targetRef": process[index + 1]["id"],
                            "condition": None,
                        }
                    )

        # Loop through the elements and flows to find the incoming and outgoing flows
        for element in elements:
            element["incoming"] = [
                flow["id"] for flow in flows if flow["targetRef"] == element["id"]
            ]
            element["outgoing"] = [
                flow["id"] for flow in flows if flow["sourceRef"] == element["id"]
            ]

        return {"elements": elements, "flows": flows}
